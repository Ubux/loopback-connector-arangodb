// Generated by CoffeeScript 1.10.0
var ArangoDBConnector, Connector, GeoPoint, _, _idIncluded, ajs, async, debug, generateConnObject, initialize, merge, qb, url,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

url = require('url');

merge = require('extend');

async = require('async');

_ = require('underscore');

Connector = require('loopback-connector').Connector;

GeoPoint = require('loopback-datasource-juggler').GeoPoint;

debug = require('debug')('loopback:connector:arango');

ajs = require('arangojs');

qb = require('aqb');

exports.generateConnObject = generateConnObject = function(settings) {
  var database, dbUrl, generated, obj, parsed, promise;
  if (settings.url) {
    parsed = url.parse(settings.url);
    generated = {};
    generated.protocol = 'http:';
    generated.hostname = parsed.hostname || '127.0.0.1';
    generated.port = parsed.port || 8529;
    if (parsed.auth != null) {
      generated.auth = parsed.auth;
    }
    database = parsed.path.slice(1).split('/')[0] || 'loopback_db';
    dbUrl = url.format(generated);
  } else {
    obj = {};
    obj.protocol = 'http:';
    obj.hostname = settings.host || '127.0.0.1';
    obj.port = settings.port || 8529;
    if (settings.username && settings.password) {
      obj.auth = settings.username + ":" + settings.password;
    }
    database = settings.database || settings.db || 'loopback_db';
    dbUrl = url.format(obj);
  }
  promise = settings.promise || false;
  return {
    url: dbUrl,
    databaseName: database,
    promise: promise
  };
};


/*
Decide if id should be included
@param {Object} fields
@returns {Boolean}
@private
 */

_idIncluded = function(fields, idName) {
  var f, i, len;
  if (!fields) {
    return true;
  }
  if (Array.isArray(fields)) {
    return fields.indexOf(idName) >= 0;
  }
  if (fields[idName]) {
    return true;
  }
  if (indexOf.call(fields, idName) >= 0 && !fields[idName]) {
    return false;
  }
  for (i = 0, len = fields.length; i < len; i++) {
    f = fields[i];
    return !fields[f];
  }
  return true;
};


/*
  Initialize the ArangoDB connector for the given data source

  @param dataSource [DataSource] The data source instance
  @param callback [Function] The callback function
 */

initialize = function(dataSource, callback) {
  var settings;
  if (ajs == null) {
    return;
  }
  dataSource.driver = ajs;
  settings = generateConnObject(dataSource.settings);
  dataSource.connector = new ArangoDBConnector(settings, dataSource);
  if (callback != null) {
    return dataSource.connector.connect(callback);
  }
};

exports.initialize = initialize;


/*
  Loopback Arango Connector

  @author Navid Nikpour
 */

ArangoDBConnector = (function(superClass) {
  extend(ArangoDBConnector, superClass);


  /*
    The constructor for ArangoDB connector
    @constructor
  
    @param dataSource [Object] Object to connect this connector to a data source
    @option settings host [String] The host/ip address to connect with
    @option settings port [Number] The port to connect with
    @option settings database/db [String] The database to connect with
    @option settings headers [Object] Object with header to include in every request
  
    @param dataSource [DataSource] The data source instance
   */

  function ArangoDBConnector(settings, dataSource) {
    ArangoDBConnector.__super__.constructor.call(this, 'arangodb', settings);
    this.debug = dataSource.settings.debug || debug.enabled;
    this.dataSource = dataSource;
    this.qb = require('aqb');
    this.db = ajs(this.settings);
    this.api = this.db.route('_api');
    this.returnVariable = 'result';
  }


  /*
    Connect to ArangoDB
  
    @param callback [Function] The callback function, called the with created connection
   */

  ArangoDBConnector.prototype.connect = function(callback) {
    if (this.debug) {
      debug('ArangoDB connection is called with settings: #{JSON.stringify @settings}');
    }
    return process.nextTick(function() {
      return callback && callback(null, this.db);
    });
  };


  /*
    Get the types of this connector
  
    @return [Array<String>] The types of connectors this connector belongs to
   */

  ArangoDBConnector.prototype.getTypes = function() {
    return ['db', 'nosql', 'arangodb'];
  };


  /*
    The default Id type
  
    @return [Object] The class to build the Id Value with
   */

  ArangoDBConnector.prototype.getDefaultIdType = function() {
    return String;
  };


  /*
    Get the model class for a certain model name
  
    @param model [String] The model name to lookup
  
    @return [Object] The model class of this model
   */

  ArangoDBConnector.prototype.getModelClass = function(model) {
    return this._models[model];
  };


  /*
    Get the collection name for a certain model name
  
    @param model [String] The model name to lookup
  
    @return [Object] The collection name for this model
   */

  ArangoDBConnector.prototype.getCollectionName = function(model) {
    var modelClass, ref;
    modelClass = this.getModelClass(model);
    if (modelClass.settings.arangodb) {
      model = ((ref = modelClass.settings.arangodb) != null ? ref.collection : void 0) || model;
    }
    return model;
  };


  /*
    Converts the retrieved data from the database to JSON, based on the properties of a given model
  
    @param model [String] The model name to look up the properties
    @param data [Object] The data from DB
  
    @return [Object] The converted data as an JSON Object
   */

  ArangoDBConnector.prototype.fromDatabase = function(model, data) {
    var key, props, val;
    if (data == null) {
      return null;
    }
    props = this.getModelClass(model).properties;
    for (key in props) {
      val = props[key];
      if ((data[key] != null) && (val != null) && val.type === Buffer) {
        data[key] = new Buffer(data[key]);
      }
      if ((data[key] != null) && (val != null) && val.type === Date) {
        data[key] = new Date(data[key]);
      }
      if ((data[key] != null) && (val != null) && val.type === GeoPoint) {
        data[key] = new GeoPoint({
          lat: data[key].lat,
          lng: data[key].lng
        });
      }
    }
    return data;
  };


  /*
    Execute a query with AQL and binded variables
  
    @param query [String|Object] The AQL query to execute
    @param bindVars [Object] The variables bound to the AQL query
    @param callback [Function] The callback function, called with a (possible) error object and the query's cursor
   */

  ArangoDBConnector.prototype.execute = function(query, bindVars, callback) {
    var context, self;
    self = this;
    if (typeof bindVars === 'function' && (callback == null)) {
      callback = bindVars;
      bindVars = {};
    }
    context = {
      req: {
        aql: query,
        params: bindVars
      }
    };
    return this.notifyObserversAround('execute', context, function(context, done) {
      return self.executeAQL(context.req.aql, context.req.params, function(err, result) {
        context.res = result && result._result;
        return done(err, result);
      });
    }, callback);
  };

  ArangoDBConnector.prototype.executeAQL = function(query, bindVars, callback) {
    var q;
    if (this.debug) {
      if (typeof query.toAQL === 'function') {
        q = query.toAQL();
      } else {
        q = query;
      }
      debug("query: " + q + " bindVars: " + (JSON.stringify(bindVars)));
    }
    return this.db.query(query, bindVars, function(err, cursor) {
      var authErr;
      if ((err == null) && (cursor.length = 0)) {
        authErr = new Error('Authentication failed');
        return callback(authErr);
      } else {
        return callback(err, cursor);
      }
    });
  };


  /*
    Checks the version of the ArangoDB
  
    @param callback [Function] The calback function, called with a (possible) error object and the server versio
   */

  ArangoDBConnector.prototype.getVersion = function(callback) {
    if (this.version != null) {
      return callback(null, this.version);
    } else {
      return this.api.get('version', function(err, result) {
        if (err) {
          callback(err);
        }
        this.version = result.body;
        return callback(null, this.version);
      });
    }
  };


  /*
    Create a new model instance for the given data
  
    @param model [String] The model name
    @param data [Object] The data to create
    @param callback [Function] The callback function, called with a (possible) error object and the created object's id
   */

  ArangoDBConnector.prototype.create = function(model, data, callback) {
    var aql, bindVars, id, idName, idValue, self;
    if (this.debug) {
      debug("create model " + model + " with data: " + (JSON.stringify(data)));
    }
    self = this;
    idValue = this.getIdValue(model, data);
    idName = this.idName(model);
    if ((idValue == null) || typeof idValue === 'undefined') {
      delete data[idName];
    } else {
      if (typeof idValue !== this.getDefaultIdType()) {
        id = this.getDefaultIdType()(idValue);
      }
      data._key = id;
      if (idName !== '_key') {
        delete data[idName];
      }
    }
    aql = qb.insert('@data')["in"]('@@collection').returnNew('inserted');
    bindVars = {
      data: data,
      '@collection': this.getCollectionName(model)
    };
    return this.execute(aql, bindVars, function(err, result) {
      var idType, modelClass, num;
      if (err) {
        return callback(err);
      }
      idValue = result._result[0]._key;
      modelClass = self._models[model];
      idType = modelClass.properties[idName].type;
      if (idType === Number) {
        num = Number(idValue);
        if (!isNaN(num)) {
          idValue = num;
        }
      }
      delete data._key;
      data[idName] = idValue;
      return callback(err, idValue);
    });
  };


  /*
    Save the model instance for the given data
  
    @param model [String] The model name
    @param data [Object] The updated data to save or create
    @param callback [Function] The callback function, called with a (possible) error object and the number of affected objects
   */

  ArangoDBConnector.prototype.save = function(model, data, options, callback) {
    if (this.debug) {
      debug("save for " + model + " with data: " + (JSON.stringify(data)));
    }
    return this.updateOrCreate(model, data, options, callback);
  };


  /*
    Update if the model instance exists with the same id or create a new instance
  
    @param model [String] The model name
    @param data [Object] The model instance data
    @param callback [Function] The callback function, called with a (possible) error object and updated or created object
   */

  ArangoDBConnector.prototype.updateOrCreate = function(model, data, options, callback) {
    var aql, bindVars, dataI, idName, idValue, self;
    if (this.debug) {
      debug("updateOrCreate for Model " + model + " with data: " + (JSON.stringify(data)));
    }
    this.getVersion(function(err, v) {
      var version;
      version = new RegExp(/[2-9]+\.[6-9]+\.[0-9]+/).test(v.version);
      if (err || !version) {
        err = new Error("Error updateOrCreate not supported for version {#v}");
        return callback(err);
      }
    });
    self = this;
    idValue = this.getIdValue(model, data);
    idName = this.idName(model);
    if (typeof idValue === 'number') {
      idValue = new String(idValue);
    }
    delete data[idName];
    dataI = _.clone(data);
    dataI._key = idValue;
    aql = 'UPSERT {_key: @id} INSERT @dataI UPDATE @data IN @@collection RETURN {doc: UNSET(NEW, ["_id", "_rev"]), isNewInstance: OLD ? false : true }';
    bindVars = {
      '@collection': this.getCollectionName(model),
      id: idValue,
      dataI: dataI,
      data: data
    };
    return this.execute(aql, bindVars, function(err, result) {
      var isNewInstance, newDoc;
      if (result && result._result[0]) {
        newDoc = result._result[0].doc;
        isNewInstance = {
          isNewInstance: result._result[0].isNewInstance
        };
        self.setIdValue(model, data, newDoc._key);
        self.setIdValue(model, newDoc, newDoc._key);
        if (idName !== '_key') {
          delete newDoc._key;
        }
      }
      return callback(err, newDoc, isNewInstance);
    });
  };


  /*
    Check if a model instance exists by id
  
    @param model [String] The model name
    @param id [String] The id value
    @param callback [Function] The callback function, called with a (possible) error object and an boolean value if the specified object existed (true) or not (false)
   */

  ArangoDBConnector.prototype.exists = function(model, id, callback) {
    if (this.debug) {
      debug("exists for " + model + " with id: " + id);
    }
    return this.find(model, id, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, result._result.length > 0);
    });
  };


  /*
    Find a model instance by id
  
    @param model [String] model The model name
    @param id [String] id The id value
    @param callback [Function] The callback function, called with a (possible) error object and the found object
   */

  ArangoDBConnector.prototype.find = function(model, id, callback) {
    var aql, bindVars;
    if (this.debug) {
      debug("find for " + model + " with id: " + id);
    }
    aql = qb["for"](this.returnVariable)["in"]('@@collection').filter(qb.eq(this.returnVariable + '._key', '@id')).limit(1)["return"](qb.fn('UNSET')(this.returnVariable, ['"_id"', '"_rev"']));
    bindVars = {
      '@collection': this.getCollectionName(model),
      id: id
    };
    return this.execute(aql, bindVars, function(err, result) {
      if (err) {
        return callback(err);
      }
      if (result._result.length > 0) {
        return callback(null, result._result[0]);
      }
      return callback(null, result._result);
    });
  };


  /*
    Extracts where relevant information from the filter for a certain model
    @param [String] model The model name
    @param [Object] filter The filter object, also containing the where conditions
    @param [String] returnVariable The variable to build the where conditions on
  
    @return return [Object]
    @option return aqlArray [Array] The issued conditions as an array of AQL query builder objects
    @option return bindVars [Object] The variables, bound in the conditions
    @option return geoObject [Object] An query builder object containing possible parameters for a geo query
   */

  ArangoDBConnector.prototype._buildWhere = function(model, where, index) {
    var aqlArray, assignNewQueryVariable, bindVars, condProp, condValue, fn, geoExpr, idName, self;
    if (this.debug) {
      debug("Evaluating where object " + (JSON.stringify(where)) + " for Model " + model);
    }
    self = this;
    if ((where == null) || typeof where !== 'object') {
      return;
    }
    aqlArray = [];
    bindVars = {};
    geoExpr = {};
    index = index || 0;
    assignNewQueryVariable = function(value) {
      var partName;
      partName = 'param_' + (index++);
      bindVars[partName] = value;
      return '@' + partName;
    };
    idName = this.idName(model);

    /*
      the where object comes in two flavors
    
       - where[prop] = value: this is short for "prop" equals "value"
       - where[prop][op] = value: this is the long version and stands for "prop" "op" "value"
     */
    fn = function() {
      var a, aql, c, collection, cond, condOp, lat, long, ref;
      if (condProp === idName) {
        condProp = '_key';
        if (typeof condValue === 'number') {
          condValue = new String(condValue);
        }
      }
      if (condProp === 'and' || condProp === 'or' || condProp === 'nor') {
        if (Array.isArray(condValue)) {
          aql = qb;
          for (c in condValue) {
            a = condValue[c];
            cond = self._buildWhere(model, a, ++index);
            aql = aql[condProp](cond.aqlArray[0]);
            bindVars = merge(true, bindVars, cond.bindVars);
          }
          aqlArray.push(aql);
          aql = null;
        }
        return;
      }
      if (condValue && condValue.constructor.name === 'Object') {
        condOp = Object.keys(condValue)[0];
        condValue = condValue[condOp];
      }
      if (condOp) {
        switch (false) {
          case condOp !== 'lte' && condOp !== 'lt' && condOp !== 'gte' && condOp !== 'gt' && condOp !== 'eq' && condOp !== 'neq':
            return aqlArray.push(qb[condOp](self.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
          case condOp !== 'between':
            return aqlArray.push([qb.gte(self.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue[0]))), qb.lte(self.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue[1])))]);
          case condOp !== 'like':
            return aqlArray.push(qb.not(qb.LIKE(self.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)))));
          case condOp !== 'nlike':
            return aqlArray.push(qb.LIKE(self.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
          case condOp !== 'nin':
            return aqlArray.push(qb.not(qb["in"](self.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)))));
          case condOp !== 'inq':
            condValue = (function() {
              var i, len, results;
              results = [];
              for (i = 0, len = condValue.length; i < len; i++) {
                cond = condValue[i];
                results.push(cond.toString());
              }
              return results;
            })();
            return aqlArray.push(qb["in"](self.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
          case condOp !== 'near':
            ref = condValue.split(','), lat = ref[0], long = ref[1];
            collection = this.getCollectionName(model);
            if (where.limit != null) {
              return geoExpr = qb.NEAR(collection, lat, long, where.limit);
            } else {
              return geoExpr = qb.NEAR(collection, lat, long);
            }
            break;
          default:
            return console.warn('No matching operatorfor : ', condOp);
        }
      } else {
        return aqlArray.push(qb.eq(self.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
      }
    };
    for (condProp in where) {
      condValue = where[condProp];
      fn();
    }
    return {
      aqlArray: aqlArray,
      bindVars: bindVars,
      geoExpr: geoExpr
    };
  };


  /*
    Find matching model instances by the filter
  
    @param [String] model The model name
    @param [Object] filter The filter
    @param [Function] callback Callback with (possible) error object or list of objects
   */

  ArangoDBConnector.prototype.all = function(model, filter, options, callback) {
    var aql, bindVars, field, fields, i, id, idName, indexId, j, len, len1, m, order, ref, ref1, self, w, where;
    if (this.debug) {
      debug("all for " + model + " with filter " + (JSON.stringify(filter)));
    }
    self = this;
    idName = this.idName(model);
    bindVars = {
      '@collection': this.getCollectionName(model)
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (filter.where) {
      if (filter.where[idName]) {
        id = filter.where[idName];
        delete filter.where[idName];
        if (typeof id === 'number') {
          id = String(id);
        }
        filter.where._key = id;
      }
      where = this._buildWhere(model, filter.where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    if (filter.order) {
      if (typeof filter.order === 'string') {
        filter.order = filter.order.split(',');
      }
      ref1 = filter.order;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        order = ref1[j];
        m = order.match(/\s+(A|DE)SC$/);
        field = order.replace(/\s+(A|DE)SC$/, '').trim();
        if (field === idName) {
          field = '_key';
        }
        if (m && m[1] === 'DE') {
          aql = aql.sort(this.returnVariable + '.' + field, 'DESC');
        } else {
          aql = aql.sort(this.returnVariable + '.' + field, 'ASC');
        }
      }
    } else {
      aql = aql.sort(this.returnVariable + '._key');
    }
    if (filter.limit) {
      aql = aql.limit(filter.skip, filter.limit);
    }
    fields = _.clone(filter.fields);
    if (fields) {
      indexId = fields.indexOf('id');
      if (indexId !== -1) {
        fields[indexId] = '_key';
      }
      fields = (function() {
        var k, len2, results;
        results = [];
        for (k = 0, len2 = fields.length; k < len2; k++) {
          field = fields[k];
          results.push('"' + field + '"');
        }
        return results;
      })();
      aql = aql["return"](qb.fn('KEEP')(this.returnVariable, fields));
    } else {
      aql = aql["return"](qb.fn('UNSET')(this.returnVariable, ['"_id"', '"_rev"']));
    }
    return this.execute(aql, bindVars, function(err, result) {
      var cursorToArray, r;
      if (err) {
        return callback(err);
      }
      cursorToArray = function(r) {
        if (_idIncluded(filter.fields, idName)) {
          self.setIdValue(model, r, r._key);
        }
        if (idName !== '_key') {
          delete r._key;
        }
        return r = self.fromDatabase(model, r);
      };
      result = (function() {
        var k, len2, ref2, results;
        ref2 = result._result;
        results = [];
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          r = ref2[k];
          results.push(cursorToArray(r));
        }
        return results;
      })();
      if (filter.include != null) {
        return self._models[model].model.include(result, filter.include, options, callback);
      } else {
        return callback(null, result);
      }
    });
  };


  /*
  Delete a model instance by id
  
  @param model [String] model The model name
  @param id [String] id The id value
  @param callback [Function] The callback function, called with a (possible) error object and the number of affected objects
   */

  ArangoDBConnector.prototype.destroy = function(model, id, callback) {
    var aql, bindVars;
    if (this.debug) {
      debug("delete for " + model + " with id " + id);
    }
    aql = qb["for"](this.returnVariable)["in"]('@@collection').filter(qb.eq(this.returnVariable + '._key', '@id')).remove(this.returnVariable)["in"]('@@collection').returnOld('removed');
    bindVars = {
      '@collection': this.getCollectionName(model),
      id: id
    };
    return this.execute(aql, bindVars, function(err, result) {
      return callback && callback(err, result && result._result.length);
    });
  };


  /*
    Delete all instances for the given model
  
    @param [String] model The model name
    @param [Object] [where] The filter for where
    @param [Function] callback Callback with (possible) error object or the number of affected objects
   */

  ArangoDBConnector.prototype.destroyAll = function(model, where, callback) {
    var aql, bindVars, collection, i, len, ref, w;
    if (this.debug) {
      debug("destroyAll for " + model + " with where " + (JSON.stringify(where)));
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (!_.isEmpty(where)) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = aql.remove(this.returnVariable)["in"]('@@collection').returnOld('removed');
    return this.execute(aql, bindVars, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, result._result.length);
    });
  };


  /*
    Count the number of instances for the given model
  
    @param [String] model The model name
    @param [Function] callback Callback with (possible) error object or the number of affected objects
    @param [Object] where The filter for where
   */

  ArangoDBConnector.prototype.count = function(model, where, options, callback) {
    var aql, bindVars, collection, i, len, ref, w;
    if (this.debug) {
      debug("count for " + model + " with where " + (JSON.stringify(where)));
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (!_.isEmpty(where)) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = aql["return"](qb.fn('UNSET')(this.returnVariable, ['"_id"', '"_rev"']));
    return this.execute(aql, bindVars, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, result._result.length);
    });
  };


  /*
    Update properties for the model instance data
  
    @param [String] model The model name
    @param [String] id The models id
    @param [Object] data The model data
    @param [Function] callback Callback with (possible) error object or the updated object
   */

  ArangoDBConnector.prototype.updateAttributes = function(model, id, data, callback) {
    var aql, bindVars, idName, self;
    if (this.debug) {
      debug("updateAttributes for " + model + " with id " + id + " and data " + (JSON.stringify(data)));
    }
    self = this;
    if (id === Number) {
      id = new String(id);
    }
    idName = this.idName(model);
    bindVars = {
      '@collection': this.getCollectionName(model),
      id: id,
      data: data
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection').filter(qb.eq(this.returnVariable + '._key', '@id')).update(this.returnVariable)["with"]('@data')["in"]('@@collection').returnNew('updated');
    return this.execute(aql, bindVars, function(err, result) {
      if (result && result._result[0]) {
        result = result._result[0];
        delete result['_id'];
        delete result['_rev'];
        self.setIdValue(model, result, id);
        if (idName !== '_key') {
          delete result._key;
        }
      }
      return callback && callback(err, result);
    });
  };


  /*
    Update all matching instances
  
    @param [String] model The model name
    @param [Object] where The search criteria
    @param [Object] data The property/value pairs to be updated
    @param [Function] callback Callback with (possible) error object or the number of affected objects
   */

  ArangoDBConnector.prototype.update = function(model, where, data, callback) {
    return this.updateAll(model, where, data, callback);
  };

  ArangoDBConnector.prototype.updateAll = function(model, where, data, callback) {
    var aql, bindVars, collection, i, idName, len, ref, w;
    if (this.debug) {
      debug("updateAll for " + model + " with where " + (JSON.stringify(where)) + " and data " + (JSON.stringify(data)));
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection,
      data: data
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (where) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = aql.update(this.returnVariable)["with"]('@data')["in"]('@@collection');
    idName = this.idName(model);
    delete data[idName];
    return this.execute(aql, bindVars, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, {
        count: result.extra.stats.writesExecuted
      });
    });
  };


  /*
    Perform autoupdate for the given models. It basically calls ensureIndex
  
    @param [String[]] [models] A model name or an array of model names. If not present, apply to all models
    @param [Function] [cb] The callback function
   */

  ArangoDBConnector.prototype.autoupdate = function(models, cb) {
    var self;
    self = this;
    if (this.db) {
      if (this.debug) {
        debug('autoupdate for model %s', models);
      }
      if ((!cb) && (typeof models === 'function')) {
        cb = models;
        models = void 0;
      }
      if (typeof models === 'string') {
        models = [models];
      }
      models = models || Object.keys(this._models);
      return async.each(models, (function(model, modelCallback) {
        var index, indexList, indexName, indexes, options, propIdx, property, ref;
        indexes = self._models[model].settings.indexes || [];
        indexList = [];
        index = {};
        options = {};
        if (typeof indexes === 'object') {
          for (indexName in indexes) {
            index = indexes[indexName];
            if (index.keys) {
              options = index.options || {};
              options.name = options.name || indexName;
              index.options = options;
            } else {
              options = {
                name: indexName
              };
              index = {
                keys: index,
                options: options
              };
            }
            indexList.push(index);
          }
        } else if (Array.isArray(indexes)) {
          indexList = indexList.concat(indexes);
        }
        ref = this._models[model].properties;
        for (propIdx in ref) {
          property = ref[propIdx];
          if (property.index) {
            index = {};
            index[propIdx] = 1;
            if (typeof property.index === 'object') {
              if (typeof property.index.arangodb === 'object') {
                options = property.index.arangodb;
                index[propIdx] = options.kind || 1;
                if (property.index.uniqe === true) {
                  options.unique = true;
                }
              } else {
                options = property.index;
              }
              if (options.background === void 0) {
                options.background = true;
              }
            } else {
              options = {
                background: true
              };
              if (property.unique) {
                options.unique = true;
              }
            }
            indexList.push({
              keys: index,
              options: options
            });
          }
        }
        if (this.debug) {
          debug('create indexes');
        }
        return async.each(indexList, (function(index, indexCallback) {
          if (this.debug) {
            debug('createIndex: %s', index);
          }
          return self.collection(model).createIndex(index.fields || index.keys, index.options, indexCallback);
        }), modelCallback);
      }), cb);
    } else {
      return this.dataSource.once('connected', function() {
        return this.autoupdate(models, cb);
      });
    }
  };


  /*
    Perform automigrate for the given models. It drops the corresponding collections and calls ensureIndex
  
    @param [String[]] [models] A model name or an array of model names. If not present, apply to all models
    @param [Function] [cb] The callback function
   */

  ArangoDBConnector.prototype.automigrate = function(models, cb) {
    var self;
    self = this;
    if (this.db) {
      if (this.debug) {
        debug("automigrate for model " + models);
      }
      if ((!cb) && (typeof models === 'function')) {
        cb = models;
        models = void 0;
      }
      if (typeof models === 'string') {
        models = [models];
      }
      models = models || Object.keys(this._models);
      return async.eachSeries(models, (function(model, modelCallback) {
        var collectionName;
        collectionName = self.getCollectionName(model);
        debug('drop collection %s for model %s', collectionName, model);
        return self.db.dropCollection(model, function(err, collection) {
          if (err) {
            if (err.response.body != null) {
              err = err.response.body;
              if (!(err.error === true && err.errorNum === 1203 && err.errorMessage === 'unknown collection \'' + model + '\'')) {
                return modelCallback(err);
              }
            }
          }
          debug('create collection %s for model %s', collectionName, model);
          return self.db.createCollection(model, modelCallback);
        });
      }), (function(err) {
        return cb && cb(err);
        return self.autoupdate(models, cb);
      }));
    } else {
      return this.dataSource.once('connected', function() {
        return this.automigrate(models(cb));
      });
    }
  };

  return ArangoDBConnector;

})(Connector);

exports.ArangoDBConnector = ArangoDBConnector;
